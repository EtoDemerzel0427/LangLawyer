# Conan & CMake Deep Dive

This guide explains how the LangLawyer project wires Conan and CMake together, what each generator does, and how the CMake targets are structured. Use it as a reference when you add new libraries/snippets or tweak the build.

---

## 1. Conan workflow

### 1.1 Recipe overview (`conanfile.py`)

- **`set_version()`** â€“ runs `git describe --tags --dirty --always` so the package version matches your latest tag. Falls back to `0.0.0` if tags arenâ€™t available.
- **`options/default_options`** â€“ currently only `save_temps` (Boolean). Toggling it propagates to CMakeâ€™s `ENABLE_SAVE_TEMPS` cache variable.
- **`layout()`** â€“ calls `cmake_layout(self)`, giving Conan a predictable folder structure under `build/<profile>/` (bin/, lib/, generators/, etc.).
- **`generate()`** â€“ creates the toolchain and dependency files:
  - `CMakeToolchain` writes `conan_toolchain.cmake`, injecting compiler settings, build flags, and custom cache variables (e.g. `ENABLE_SAVE_TEMPS`).
  - `CMakeDeps` writes `Find<Package>.cmake` and `<Package>Config.cmake` files. Once you declare requirements, your `find_package()` calls resolve to the Conan-provided packages.
- **`build()`** â€“ instantiates `CMake()`, runs `configure()` (consuming the generated toolchain/presets), then `build()`.
- **`package()`** â€“ runs `cmake.install()` so the install rules in the project copy binaries, headers, and targets into the Conan package folder.

The build flow is therefore:

```
conan install â€¦ â†’ generate toolchain/deps files â†’ (optionally) cmake configure
conan build â€¦   â†’ reuse those files to configure & build in the requested folder
```

### 1.2 What is a generator?

In Conan, *generators* are small pieces of logic that translate package metadata into build-system friendly files or environment scripts. After `conan install`, they produce artifacts you can feed to your build toolâ€”toolchain files, dependency graphs, command wrappers, etc. In Conan 2, generators live in Python and are configured per recipe (often via the `generate()` method).

- They do **not** build anything themselves. Their job is to prepare the environment for the build system.
- You can enable multiple generators; each one writes into `build/<profile>/generators/` (unless you override the destination).
- Typical examples: `CMakeToolchain`, `CMakeDeps`, `VirtualEnv`, `PkgConfigDeps`.

### 1.3 Conan 2 generators used here

| Generator       | Output                                      | Purpose in this project                                  |
|-----------------|---------------------------------------------|----------------------------------------------------------|
| `CMakeToolchain`| `conan_toolchain.cmake`, presets, env files | Pins compiler, standard, and platform flags; exports cache variables like `ENABLE_SAVE_TEMPS`; configures the CMake invocation. |
| `CMakeDeps`     | `Find<dep>.cmake`, `<dep>Config.cmake`, presets | Provides `find_package()` modules/config files so our project (and anything depending on the package) resolves Conan-managed dependencies. |

Both drop their files under `build/<profile>/generators/`, and the auto-generated `CMakeUserPresets.json` in the repo root includes those presets so IDEs can choose them.

### 1.4 CMake presets generated by Conan

Every `conan install` run writes two preset files:

- `build/<profile>/generators/CMakePresets.json` â€“ the actual project presets (`configure`, `build`, `test`) emitted by Conan. Example preset name: `conan-release`.
- `CMakeUserPresets.json` at the repo root â€“ thin wrapper that includes the generated file so IDEs and CLI tooling can discover it automatically. The path is absolute to the build folder you installed into.

Usage patterns:

```bash
# After conan install â€¦ --output-folder=build/release
cmake --preset conan-release        # configure with the generated toolchain
cmake --build --preset conan-release
ctest --preset conan-release        # if you add tests
```

Running `cmake --list-presets` from the repo root shows whatever presets the last `conan install` generated. Because the include path is absolute, delete `CMakeUserPresets.json` (or rerun `conan install`) if you move or wipe the build directory.

These presets are especially handy in IDEs (CLion, VSCode, Visual Studio) that read `CMakeUserPresets.json` to offer ready-made configurations.

### 1.5 How does this differ from Conan 1?

Conan 1 used legacy (mostly text-based) generators like:

| Conan 1 generator | Typical output                        | Notes |
|-------------------|---------------------------------------|-------|
| `cmake` / `cmake_multi` | `conanbuildinfo.cmake`                | A monolithic file that you had to `include()` manually. Provided functions like `conan_basic_setup()` which modified global CMake state. |
| `cmake_paths`     | Modified `CMAKE_MODULE_PATH`/`CMAKE_PREFIX_PATH` | Helped module-mode `find_package`, but required manual include and was easy to misconfigure. |
| `virtualenv`      | Activatable scripts (`activate.sh`, etc.) | Similar concept to Conan 2â€™s `VirtualEnv`, but less structured. |

Key differences between Conan 1 and Conan 2 generator ecosystem:

- **Separation of concerns**: Conan 2 splits toolchain configuration (`CMakeToolchain`) and dependency discovery (`CMakeDeps`), whereas Conan 1â€™s `cmake` generator mixed both in one file.
- **CMake presets/toolchains**: Conan 2 integrates with modern CMake (`CMakePresets.json`, cache variables), aligning with CMakeâ€™s multi-config and cross-building features. Conan 1 required more manual CMake logic.
- **Package layout awareness**: `cmake_layout()` and the `generate()` method make it easy to influence the build directories and generator behavior per recipe. In Conan 1, you often hard-coded folder structures or relied on environment variables.
- **Extensibility**: Conan 2 generators are Python classes you can configure or even subclass; Conan 1 generators were more rigid text templates.

If you encounter old instructions referencing `conanbuildinfo.cmake`, the modern equivalent is letting `CMakeToolchain` + `CMakeDeps` write the toolchain and dependency configs, then running CMake with the generated toolchain file.

### 1.3 Configuring builds with options/profiles

- **Options** â€“ pass `-o save_temps=True` during `conan install` to enable intermediate artefacts. Each option maps to a CMake cache variable inside `generate()`.
- **Profiles** â€“ capture compiler, architecture, build type, and environment values (e.g. `compiler=clang`, custom `LIBRARY_PATH`). Helpful when you want separate presets for Apple Clang vs Homebrew LLVM.
- **Build folders** â€“ keep them separate per profile/configuration if youâ€™re using single-config generators (e.g. `build/release`, `build/debug`). With multi-config generators you can share one folder.

Typical single-config workflow (Ninja, Unix Makefiles):

```bash
conan profile detect --force
conan install . \
  --profile=default \
  --settings=build_type=Release \
  --build=missing \
  --output-folder=build/release \
  -o save_temps=True
conan build . --build-folder=build/release
```

Multi-config workflow (Ninja Multi-Config, Visual Studio, Xcode):

```bash
conan profile detect --force
conan install . \
  --profile=default \
  --settings=build_type=Debug \
  --build=missing \
  --output-folder=build \
  -o save_temps=True
conan install . \
  --profile=default \
  --settings=build_type=Release \
  --build=missing \
  --output-folder=build
conan build . --build-folder=build --config Debug
conan build . --build-folder=build --config Release
```

Install once per configuration you plan to build; the generators deposit both Debug and Release metadata in the shared `build/` folder so you can switch configurations without reconfiguring.

---

## 2. CMake building blocks (command-centric)

Instead of walking files line-by-line, this section explains the CMake commands we lean on most and how they interact.

### `add_library` / `add_executable`

- Declare targets and their sources. Libraries can be `STATIC`, `SHARED`, or `MODULE`; executables always produce runtime binaries.
- Targets are first-class objects: every property you set (include paths, compile definitions, link dependencies) travels with them semantically.
- Example: `add_library(build_process_lib SHARED lib.cpp)` creates a shared lib target named `build_process_lib`.

### `target_include_directories` and usage requirements

```cmake
target_include_directories(build_process_lib
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
        $<INSTALL_INTERFACE:include/build_process>
)
```
- `target_include_directories` is used to add include directories to a target.
- **PUBLIC / PRIVATE / INTERFACE** control propagation:
  - **PRIVATE** â€“ applies only to the target itself.
  - **PUBLIC** â€“ applies to the target and anything that links to it.
  - **INTERFACE** â€“ applies only to dependents (useful for header-only targets).
  (This concept is shared with target_link_libraries and target_compile_options)
- **Generator expressions** (`$<â€¦>`) let us distinguish build-time vs install-time properties. Two especially useful ones:
  - `$<BUILD_INTERFACE:â€¦>` â€“ active when the target is built from the source tree. Use it for include paths that only exist while developing locally (like `${CMAKE_CURRENT_SOURCE_DIR}`).
  - `$<INSTALL_INTERFACE:â€¦>` â€“ active when the target is consumed after installation or packaging. Use it for include paths relative to the install prefix (e.g., `include/build_process`).
- By combining both, our installed package advertizes clean, relocatable include directories without leaking absolute source paths.
- Thanks to propagation, `snippets/build_process` automatically sees the right headers when it links to `build_process_lib`.

### `target_link_libraries`

```cmake
target_link_libraries(build_process_app
    PRIVATE
        build_process_lib
)
```

- Wire dependencies between targets or external libraries.
- Accepts the same PUBLIC/PRIVATE/INTERFACE qualifiers:
  - If we linked `PUBLIC`, any target linking `build_process_app` later would also inherit `build_process_lib` (rare for executables but common for libraries).
  - `INTERFACE` is for header-only link targets or usage requirements with no binary output.
- When the dependency is a CMake target (like `build_process_lib`), CMake automatically carries over transitive include dirs, compile definitions, and link flags. No need for manual `-l` or `-I` manipulations.

### `target_compile_options`

- Adds compiler flags scoped to a target.
- We guard `-save-temps=obj` behind the `ENABLE_SAVE_TEMPS` cache variable:

```cmake
if(ENABLE_SAVE_TEMPS)
    target_compile_options(build_process_lib PRIVATE -save-temps=obj)
endif()
```

- Again, PUBLIC/PRIVATE/INTERFACE decide whether downstream targets inherit the flag.

### `install(TARGETS â€¦)` and `install(EXPORT â€¦)`

- `install(TARGETS â€¦)` copies the built artifacts into the install tree and records metadata (which Conan later packages). We specify runtime/lib/archive destinations and header locations.
- Common destination keywords:
  - **RUNTIME** â€“ where executables (`.exe`, `.app`, binaries) go. Typically `bin/`.
  - **LIBRARY** â€“ where shared libraries (`.so`, `.dylib`, `.dll`) go. Typically `lib/`.
  - **ARCHIVE** â€“ where static libraries (`.a`, `.lib`) go. Also `lib/`.
  - **INCLUDES** â€“ header installation prefix, used alongside `target_include_directories` to keep include paths consistent.
- You may also see the `PUBLIC_HEADER` option; it installs header files declared via `set_target_properties(TARGET PROPERTIES PUBLIC_HEADER ...)`. Itâ€™s convenient when you want CMake to copy only the headers you explicitly register on the target. `INCLUDES DESTINATION` is a simpler alternative when you already manage the header list in your `install(FILES ...)` call and just need the path to line up with the exported usage requirements.
- `install(TARGETS â€¦ EXPORT â€¦)` registers targets for export, and the companion `install(EXPORT â€¦ NAMESPACE langlawyer:: â€¦)` emits a `<target>Targets.cmake` file. Consumers can `find_package(langlawyer CONFIG)` and `target_link_libraries(... langlawyer::build_process_lib)`.
- Combined with Conanâ€™s `package()` step, this turns the internal library into a reusable component if you ever export the recipe.

### `find_package` (Config vs Module mode)

- When we install/export targets, we create Config packages; future projects call `find_package(langlawyer CONFIG)` and get back the `langlawyer::build_process_lib` imported target.
- Config mode is the default in this project because it returns fully defined targets with usage requirements and aligns with Conanâ€™s generators. For a broader comparison, see [Conan 1 vs Conan 2](conan-1-vs-2.md#ðŸš€-new-world-conan-2-generators).
- Conanâ€™s `CMakeDeps` does the same for third-party dependencies: it drops `<dep>Config.cmake` files into `build/<profile>/generators/` so our `find_package` calls resolve to Conan-managed packages instead of system copies.
- Module mode (`find_package(foo)`) searches for `FindFoo.cmake` scripts. Reserve it for legacy packages that donâ€™t ship Config files.

### `set_target_properties`

- Fine-grained way to attach metadata to a target. Most properties opt into special behaviors or wrap families of settings.
- Common usage in this project is marking public headers, but it can also control output names, versions, or visibility:

```cmake
set_target_properties(build_process_lib PROPERTIES
    PUBLIC_HEADER "api.hpp"
    OUTPUT_NAME "build_process"
)
```

- **`PUBLIC_HEADER`** interacts with `install(TARGETS â€¦ PUBLIC_HEADER DESTINATION include/...)`, allowing CMake to copy the headers you list without duplicating file paths elsewhere.
- **`OUTPUT_NAME`** changes the emitted artifactâ€™s filename while keeping the logical target name unchanged.
- If you need to tweak a single property, the helper command `set_property(TARGET build_process_lib PROPERTY CXX_STANDARD 20)` is equivalent.
- Prefer target properties over global variables (`set(CMAKE_* ...)`) when you only want to adjust one specific library or executable.

### Output directories and configuration variants

```cmake
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

foreach(_config IN LISTS CMAKE_CONFIGURATION_TYPES)
    string(TOUPPER "${_config}" _config_upper)
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${_config_upper} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${_config_upper} ${CMAKE_LIBRARY_OUTPUT_DIRECTORY})
    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${_config_upper} ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
endforeach()
```

- Forces all executables into `bin/` and libraries into `lib/` under the active build folder, making the build output predictable.
- The loop mirrors those settings for each configuration when using multi-config generators (Debug, Release, RelWithDebInfo, etc.).

---

## 3. Putting it all together

1. **Environment** â€“ Use `uv sync` in `python_env/` to get Conan installed with the pinned Python version.
2. **Install step** â€“ `conan install` generates `conan_toolchain.cmake` (with the right `ENABLE_SAVE_TEMPS` value) and dependency configs under `build/<profile>/generators/`.
3. **Build step** â€“ `conan build` (or manual `cmake --build`) compiles libraries/executables, putting artefacts in `build/<profile>/bin` and `lib`.
4. **Inspecting intermediate files** â€“ pass `-o save_temps=True` (or `-DENABLE_SAVE_TEMPS=ON`) to keep `.ii`, `.s`, and `.bc` outputs.
5. **Packaging** â€“ `conan build` followed by `conan export-pkg . --user=â€¦ --channel=â€¦` would package `langlawyer` with the installed headers + exported targets, ready for reuse.

Use this document as a living referenceâ€”extend it when you add new options, generators, or CMake patterns.
